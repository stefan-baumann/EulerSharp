using System;

namespace EulerSharp.Problem12.Naive
{
    /* Problem Description:
     * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
     * The first ten terms would be 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
     * [...]
     * What is the value of the first triangle number to have over five hundred divisors?
     * 
     * Solution Notes:
     * - x is a multiple of y if x % y == 0. So y is a factor of x if x % y == 0.
     * - This is the naive solution whithout any of the obvious optimization possibilities used which makes it not practical. Check out EulerSharp.Problem12.Optimized for a more reasonable version.
     */

    public static class Program
    {
        public static void Main(string[] args)
        {
            long result = -1;

            //Loop through all possible candidates until the result was found
            for (int candidate = 1; result == -1; candidate++)
            {
                long triangleNumber = CalculateTriangleNumber(candidate);
                int factors = CountFactors(triangleNumber);
                if (factors > 500)
                {
                    result = candidate;
                }
            }


            //Write the result to the console
            Console.WriteLine("The first triangle number which has over 500 factors is " + result);

            //Wait for a keypress before terminating the program (so that the user can read the output)
            Console.ReadKey(true);
        }

        //Helper function to calculate the nth triangle number
        public static long CalculateTriangleNumber(int n)
        {
            //Calculate the sum of all natural numbers that are smaller or equal to n
            long sum = 0;
            for (int i = 1; i <= n; i++)
            {
                sum += i;
            }

            return sum;
        }

        //Helper function to count the factors of a positive integers
        public static int CountFactors(long x)
        {
            //If x equals 1, the answer is 1
            if (x == 1)
            {
                return 1;
            }

            int factors = 2; //we don't need to check for 1 and x, so we already have 2 factors
            for (int candidate = 2; candidate <= x / 2; candidate++) //Loop through every number between 2 and the half of x
            {
                //If the candidate is a factor of x, increment the factor count
                if (x % candidate == 0)
                {
                    factors++;
                }
            }

            return factors;
        }
    }
}
