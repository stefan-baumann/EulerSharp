using System;

namespace EulerSharp.Problem12
{
    /* Problem Description:
     * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
     * The first ten terms would be 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
     * [...]
     * What is the value of the first triangle number to have over five hundred divisors?
     * 
     * Solution Notes:
     * - x is a multiple of y if x % y == 0. So y is a factor of x if x % y == 0.
     * - Calculating the triangle number for each candidate is not necessary as we can keep track of the sum by storing it in a variable and adding each candidate.
     * - Checking whether a number x has decimal digits can be done by checking whether x % 1 == 0
     */

    public static class Program
    {
        public static void Main(string[] args)
        {
            long result = -1;

            //Loop through all possible candidates until the result was found
            long sum = 0;
            for (int candidate = 1; result == -1; candidate++)
            {
                sum += candidate; //Add the candidate to the sum to form the current triangle number
                if (CountFactors(sum) > 500) //Check whether the current triangle number has more than 500 factors/divisors
                {
                    result = sum;
                }
            }
            
            //Write the result to the console
            Console.WriteLine("The first triangle number which has over 500 factors is " + result);

            //Wait for a keypress before terminating the program (so that the user can read the output)
            Console.ReadKey(true);
        }

        //Optimized helper function to count the factors of a positive integers
        public static int CountFactors(long x)
        {
            //If x equals 1, the answer is 1
            if (x == 1)
            {
                return 1;
            }

            int factors = 2; //We don't need to check for 1 and x, so we already have 2 factors
            for (int candidate = 2; candidate * candidate < x; candidate++) //Loop through every number between 2 and the square root of x
            {
                //If the candidate is a factor of x, increment the factor count
                if (x % candidate == 0)
                {
                    factors += 2;
                }
            }

            //If the integer x is a perfect square, we have to add 1 to the factor count
            if (Math.Sqrt(x) % 1 == 0)
            {
                factors++;
            }

            return factors;
        }
    }
}
